# 📊 レバレッジETF シミュレーター

対数正規分布モデルを使用して、レバレッジETFの長期投資におけるリターン分布とリスクを可視化するインタラクティブシミュレーターです。

**💡 初期値はSOXL（半導体3倍レバレッジETF）に合わせて設定**
- ドリフト：14%（半導体セクターの期待リターン）
- ボラティリティ：34%（高変動セクター）
- 金利：3%（現在の金利水準）
- 経費：0.95%（SOXLの実際の経費率）

## 🎯 プロジェクトの目的

レバレッジETFの投資判断をサポートするため、以下の重要な統計指標を可視化します：

- **対数正規分布による資産分布**の視覚化
- **投資期間の影響**を直感的に理解
- **期待値、中央値、最頻値**の比較
- **統計的優位性ゾーン**の判定
- **ボラティリティ減価**の影響評価

## ✨ 実装済み機能

### 📈 グラフ機能

1. **資産分布の比較グラフ**
   - 通常ETF (L=1) とレバレッジETF (L=任意) の分布を比較
   - 期待値、中央値、最頻値を縦線で表示
   - 投資期間に応じた分布の変化を可視化
   - リアルタイムで比率計算（期待値比、中央値比、最頻値比）

2. **モンテカルロシミュレーション時系列グラフ（日次計算版）**
   - **初期投資額100万円**からシミュレーション開始
   - **日次ベースの詳細シミュレーション**：年間252営業日（米国市場基準）で計算
   - **試行回数を1〜5,000回まで調整可能**（スライダーで変更、1刻み）
     - 回数が多いほど理論値との一致度が向上
     - 自動透明度調整で多数の軌跡も見やすく表示
   - 通常ETF (L=1) とレバレッジETF (L=任意) の時系列推移を可視化
   - **対数/線形スケール切替機能**：ボタンで表示方法を変更可能
     - 線形スケール：Y軸最大値をスライダーで調整可能（100〜5,000万円）
     - データの範囲に応じて最適な表示幅を設定可能
   - 理論期待値（破線）、理論中央値（実線）、理論最頻値（点線）を重ねて表示
   - シミュレーション結果の統計量を**万円単位**で表示（平均、中央値、最大、最小）
   - 理論値との比較で精度を確認可能
   - 日々の変動とボラティリティ減価をリアルに再現
   - 幾何ブラウン運動に基づく正確な確率モデル

3. **モンテカルロ最終資産分布グラフ（Chart.js版）**
   - **Chart.jsで高品質な描画**：軽量で高速、美しいヒストグラム表示
   - **X軸/Y軸スケール切り替え**：対数軸⇔線形軸を自由に切り替え
     - X軸: 対数軸（デフォルト）で広範囲を見やすく / 線形軸で低倍率領域を詳細に
     - Y軸: 線形軸（デフォルト）で直感的に / 対数軸でテール（外れ値）を詳細に
   - **対数スケールでビンを作成**：対数正規分布に最適化された100ビン
   - **シミュレーション回数1〜5,000回**：用途に応じて柔軟に設定
   - シミュレーション結果の最終資産倍率（元本=1）をヒストグラムで表示
   - 理論分布曲線（対数正規分布）を滑らかな線で重ねて表示
   - L=1とL=3のヒストグラムを半透明で重ね合わせ
   - 実測値と理論値の一致度を視覚的に確認
   - 確率密度で正規化（面積が1になるよう調整）
   - 試行回数を増やすほど理論曲線に近づく様子を確認可能
   - インタラクティブなツールチップで詳細情報を表示

4. **レバレッジETF vs 通常ETF 勝敗グラフ**
   - **円グラフで勝敗を視覚化**：レバレッジETFと通常ETFの勝率を一目で確認
   - **勝敗判定**：各シミュレーション試行で最終資産額を比較
     - レバレッジETF勝利（オレンジ）: L=設定値の最終資産 > L=1の最終資産
     - 通常ETF勝利（青）: L=1の最終資産 > L=設定値の最終資産
   - **勝率表示**：パーセンテージで勝率を表示
   - **統計情報**：各勝利回数と勝率を数値で確認
   - **直感的理解**：期待値は高いが勝率は低い、などの統計的特性を視覚化

5. **破産確率グラフ（NEW!）**
   - **棒グラフで破産リスクを比較**：通常ETFとレバレッジETFの破産確率を明確に表示
   - **破産の定義**：最終資産が初期投資額の1/4（25万円）以下になった場合を「破産」とする
   - **破産確率計算**：全シミュレーション試行のうち破産条件を満たした割合をパーセンテージで表示
   - **視覚的比較**：2つの棒グラフで直感的にリスク差を理解
   - **統計情報**：破産確率（%）と破産回数を数値で表示
   - **リスク認識**：レバレッジETFのボラティリティドラッグによる破産リスクの増加を可視化
   - **投資判断支援**：期待値やリターンだけでなく、下方リスクも考慮した意思決定をサポート

### ⚙️ パラメータ調整機能

すべてのパラメータをスライダーで動的に調整可能：

- **投資期間 (T)**: 1〜20年
- **レバレッジ (L)**: 1.0〜5.0倍
- **ドリフト (μ)**: 0〜0.30（年間期待リターン率）
- **ボラティリティ (σ)**: 0.01〜0.50（年間変動率）
- **金利 (b)**: 0〜0.10（レバレッジコスト）
- **経費 (c)**: 0〜0.10（年間運用経費率）
- **シミュレーション回数**: 1〜5,000回（モンテカルロ試行回数、1刻み）
- **線形スケールY軸最大値**: 100〜5,000万円（グラフ2の線形表示時の上限）

### 📊 統計カード表示

- **投資期間**: 現在選択されている期間を表示
- **リスクプレミアム**: μ - b の計算値
- **中央値優位上限**: 中央値でレバレッジETFが有利となる最大倍率
- **最頻値優位上限**: 最頻値でレバレッジETFが有利となる最大倍率

### 💡 ユーザー支援機能

- **実行ボタン**: パラメータ調整後、任意のタイミングでシミュレーション実行
- **リアルタイム値表示**: スライダー操作時に即座にパラメータ値を表示
- **ローディング表示**: 計算中の視覚的フィードバック
- **情報ボックス**: 投資期間の影響について解説
- **警告ボックス**: 長期投資のリスクについて注意喚起
- **レスポンシブデザイン**: モバイル端末でも快適に操作可能

## 🔧 使用技術

- **HTML5**: セマンティックな構造設計
- **CSS3**: グラデーション、アニメーション、レスポンシブレイアウト
- **JavaScript (ES6+)**: 数学的計算とインタラクティブ機能
- **Plotly.js 2.26.0**: 高度なデータ可視化（グラフ1-3）
- **Chart.js**: 軽量で高速なヒストグラム描画（グラフ4）
- **MathJax 3**: LaTeX形式の数式表示

## 📐 数学的モデル

### 対数正規分布のパラメータ

T年後の資産倍率 X_T は以下の対数正規分布に従います：

```
α = T × (L×μ - (L-1)×b - c - 0.5×L²×σ²)
β = √T × L × σ
```

### 統計量の計算式

- **期待値 (Mean)**: E[X_T] = exp(α + β²/2)
- **中央値 (Median)**: M[X_T] = exp(α)
- **最頻値 (Mode)**: Mode[X_T] = exp(α - β²)

### 優位性の判定条件

- **中央値優位上限**: L ≤ (2×(μ-b)/σ²) - 1
- **最頻値優位上限**: L ≤ (2×(μ-b)/(3×σ²)) - 1

## 🚀 機能エントリポイント

| 機能 | ファイル | 説明 |
|------|---------|------|
| メインページ | `index.html` | シミュレーターのメインインターフェース |

## 📝 今後の推奨開発項目

### ✅ 最近追加・修正された機能

- **数式表示**: ヘッダーにレバレッジETFの複利込み平均年利の原則を明示
  - ①増価、②減価、③金利、④経費の4要素を視覚化
  
- **2段階シミュレーションモデルに改良（重要）**: より現実的なレバレッジETF
  - **ステップ1**: 原指数（SOX）の価格推移をシミュレーション
  - **ステップ2**: レバレッジETFが原指数の日次リターンに連動
  - 原指数とレバレッジETFの関係性を正確に再現
  - 毎日コストを指数関数的に控除
  - ゼロ割れ防止機能を追加（価格が負にならない）
  
- **日次モンテカルロシミュレーション**: 年間252営業日ベースで投資期間全体にわたる資産推移をシミュレーション
  - より現実的な日々の変動を再現（米国市場の実際の営業日数に基づく）
  - レバレッジETFの日次リバランスの影響を正確に反映
  - ボラティリティ減価の累積効果を可視化
  - 対数/線形スケール切替でリスクを多角的に視覚化
  - 理論最頻値を追加表示（最も起こりやすい結果）
  - 試行回数1〜500回で動作が軽快（少数サンプルでの分散観察も可能）

### 高優先度

1. **データエクスポート機能**
   - グラフ画像のダウンロード（PNG, SVG）
   - パラメータ設定のJSON保存/読込
   - 計算結果のCSVエクスポート

2. **プリセット機能**
   - 代表的なETF（S&P500、NASDAQ100など）のパラメータプリセット
   - ユーザー設定の保存（localStorage活用）

3. **比較モード**
   - 複数のレバレッジ倍率を同時に比較
   - 異なる投資期間の並列表示

### 中優先度

4. **シミュレーション機能**
   - モンテカルロシミュレーション
   - 確率分布からのランダムサンプリング表示
   - パーセンタイル表示（10%, 25%, 75%, 90%など）

5. **教育コンテンツ**
   - 計算式の詳細説明ページ
   - インタラクティブチュートリアル
   - よくある質問（FAQ）セクション

6. **詳細分析機能**
   - 損失確率の計算（元本割れ確率など）
   - シャープレシオの計算
   - 最大ドローダウンの推定

### 低優先度

7. **デザイン強化**
   - ダークモード対応
   - カラースキームのカスタマイズ
   - アニメーション効果の追加

8. **パフォーマンス最適化**
   - Web Worker による計算の並列処理
   - グラフの描画パフォーマンス改善

9. **多言語対応**
   - 英語版の追加
   - 言語切り替え機能

## 🔧 重要な修正履歴

### v1.8.0 - グラフ5: 破産確率の追加（NEW!）

**新機能：**
レバレッジETFと通常ETFの破産確率を視覚的に比較する新しいグラフを追加しました。

**主な機能：**

1. **破産の定義**
   - 最終資産が初期投資額（100万円）の**1/4（25万円）以下**になった場合を「破産」と定義
   - 投資元本の75%以上を失う深刻な損失状態を可視化

2. **棒グラフで視覚的比較**
   - Chart.jsによる美しい棒グラフ表示
   - L=1（通常ETF）とL=設定値（レバレッジETF）を横並びで比較
   - 青（通常ETF）とオレンジ（レバレッジETF）で色分け

3. **統計情報の表示**
   - 破産確率（%）: 全試行のうち破産条件を満たした割合
   - 破産回数: 実際に破産した試行回数/全試行回数
   - 両ETFの破産リスク差をポイント表示

4. **リスク認識の向上**
   - ボラティリティドラッグによる破産リスクの増加を明確化
   - 期待値やリターンだけでなく、下方リスクも考慮した投資判断をサポート
   - レバレッジ倍率や投資期間が破産確率に与える影響を確認可能

**技術的実装：**

```javascript
// 破産確率の計算
const bankruptcyThreshold = initialValue / 4; // 25万円
const normalBankruptcyCount = finalValues1.filter(v => v <= bankruptcyThreshold).length;
const leverageBankruptcyCount = finalValuesL.filter(v => v <= bankruptcyThreshold).length;
const normalBankruptcyRate = (normalBankruptcyCount / numSimulations) * 100;
const leverageBankruptcyRate = (leverageBankruptcyCount / numSimulations) * 100;
```

**使用シーン：**
- **保守的投資家**: 破産確率が5%以下になるレバレッジ倍率を探す
- **リスク管理**: 投資期間や市場ボラティリティに応じた許容リスク範囲の確認
- **ストレステスト**: 最悪シナリオでの資産保全可能性の評価
- **教育目的**: レバレッジのリスクを具体的な数値で理解

**表示内容：**
- Y軸: 破産確率（0〜100%）
- X軸: ETFタイプ（L=1通常ETF / L=設定値レバレッジETF）
- ツールチップ: 破産確率と破産回数の詳細情報

### v1.7.1 - シミュレーション回数の上限を調整

**変更内容：**
シミュレーション回数の上限を50,000回から5,000回に変更しました。

**変更理由：**
- **パフォーマンス**: 50,000回は計算に時間がかかりすぎる
- **実用性**: 5,000回でも理論値との一致度は十分高い
- **安定性**: ブラウザの応答性を保つ

**変更点：**
```
変更前: 1〜50,000回
変更後: 1〜5,000回
```

**推奨シミュレーション回数：**

| 回数 | 用途 | 計算時間 |
|------|------|---------|
| **1〜100回** | 分散の体感、デモ | 瞬時 ⚡ |
| **100〜1,000回** | 標準的な確率分布の確認 | 1秒未満 ⚡ |
| **1,000〜3,000回** | 高精度な統計分析 | 数秒 🚀 |
| **3,000〜5,000回** | 理論値との詳細一致確認 | 5〜10秒 📊 |

**5,000回で十分な理由：**
- 中心極限定理により、1,000回以上で統計的に安定
- 3,000回程度で理論値との誤差は1%以下
- 5,000回で理論値とほぼ完全に一致

### v1.7.0 - ボラティリティドラッグの計算バグ修正（重大なバグ修正）

**🐛 重大なバグの発見と修正：**

Geminiによる詳細な検証により、モンテカルロシミュレーションのボラティリティドラッグ計算に重大な誤りが発見されました。

**問題点：**

シミュレーションモデルと理論モデルでボラティリティドラッグの計算が不一致でした。

| モデル | ボラティリティドラッグ | L=3の場合 |
|--------|---------------------|-----------|
| **理論値（正しい）** | `0.5 × L² × σ²` | `4.5 × σ²` |
| **シミュレーション（誤り）** | `0.5 × L × σ²` | `1.5 × σ²` |

→ シミュレーションはドラッグを**3分の1**しか計算していなかった！

**影響：**
- グラフ2, 3, 4のモンテカルロシミュレーションでレバレッジETFが過大評価されていた
- グラフ4の勝率が異常に高かった（理論値と不整合）
- レバレッジETFの中央値・最頻値が実際より高く表示されていた

**修正内容：**

`trackIndexWithLeverage`関数に不足しているボラティリティドラッグを追加：

```javascript
// 修正前（バグ）
function trackIndexWithLeverage(indexSimulations, L, b, c, initialValue = 100) {
    // ...
    const costFactor = Math.exp(-(L - 1) * b * dt - c * dt);
    // ボラティリティドラッグが不足！
}

// 修正後（正しい）
function trackIndexWithLeverage(indexSimulations, L, b, c, sigma, initialValue = 100) {
    const sigma2 = sigma * sigma;
    // ...
    
    // 不足しているボラティリティドラッグを計算
    // 理論値: 0.5 × L² × σ²
    // 既に含まれている分: 0.5 × L × σ²
    // 不足分: 0.5 × L × (L-1) × σ²
    const missingDecay = 0.5 * L * (L - 1) * sigma2 * dt;
    
    // コストファクターに不足分を追加
    const costFactor = Math.exp(-(L - 1) * b * dt - c * dt - missingDecay);
}
```

**数式の導出：**

原指数の対数リターン: `dX = (μ - 0.5σ²)dt + σdW`

レバレッジETFの対数リターン: `dY = L × dX`

これを展開すると：
```
dY = L(μ - 0.5σ²)dt + LσdW
   = Lμdt - 0.5Lσ²dt + LσdW
```

しかし、正しい理論値は：
```
E[dY] = (Lμ - 0.5L²σ²)dt
```

差分（不足分）：
```
(Lμ - 0.5L²σ²) - (Lμ - 0.5Lσ²) = -0.5L²σ² + 0.5Lσ²
                                = -0.5L(L-1)σ²
```

**修正後の効果：**

デフォルトパラメータ（L=3, σ=34%, T=1年）の場合：

| 項目 | 修正前（誤り） | 修正後（正しい） |
|------|--------------|----------------|
| **L=3の理論中央値** | 約100万円 | **約84万円** |
| **L=3の勝率** | 約60% | **約40%** |
| **ドラッグの影響** | -1.5σ² = -17% | **-4.5σ² = -52%** |

→ **レバレッジETFのリスクが正しく反映される**ようになりました。

**検証方法：**

修正後、以下を確認してください：

1. **グラフ1とグラフ3の一致**
   - グラフ3のヒストグラムがグラフ1の理論曲線に一致
   
2. **グラフ4の勝率が理論値と一致**
   - コンソールのデバッグ情報で確認
   - 理論中央値の大小と勝率が一致

3. **デフォルト設定（L=3, σ=34%）の場合**
   - L=3の勝率が約40%前後（50%以下）
   - L=1の方が有利（勝率約60%）

**Geminiに感謝：**

この重大なバグを発見していただいたGeminiと、鋭い指摘をしていただいたユーザーに深く感謝いたします。これにより、シミュレーターが理論的に正しく、実際のレバレッジETFの特性を正確に反映するようになりました。

### v1.6.1 - グラフ4の検証機能を強化

**改良内容：**
グラフ4（勝敗円グラフ）の勝率が理論値と一致するか詳細に検証できるよう、デバッグ機能を大幅に強化しました。

**検証機能の詳細：**

1. **個別試行の詳細表示**
   - 最初の20試行の結果を詳細表示
   - L=1とL=3の最終資産額を表示
   - 各試行の勝者を表示

2. **統計情報の比較**
   - 理論中央値 vs 実測中央値
   - 理論期待値 vs 実測平均値
   - 全試行の平均倍率

3. **理論値との整合性チェック**
   - 理論中央値から期待される勝率を計算
   - 実測勝率が理論値と一致するか自動判定
   - 不整合の場合は試行回数を増やすよう提案

**コンソール出力例：**
```
=== 勝敗計算デバッグ ===
試行回数: 1000
最初の20試行の結果:
試行1: L=1=105.23万円(1.05x), L=3=98.45万円(0.98x), 勝者=L=1
試行2: L=1=98.76万円(0.99x), L=3=118.34万円(1.18x), 勝者=L=3
...

全試行の平均倍率 L=1: 1.043x
全試行の平均倍率 L=3: 1.089x

=== 理論値との比較 ===
理論中央値 L=1: 104.36万円 (1.044x)
理論中央値 L=3: 84.39万円 (0.844x)
理論中央値比: 0.809

実測中央値 L=1: 103.87万円 (1.039x)
実測中央値 L=3: 85.12万円 (0.851x)

✓ 理論的には、通常ETFの中央値の方が高い → レバレッジETF勝率50%以下が期待される
期待される勝率（理論値）: < 50%

レバレッジETF勝利: 420
通常ETF勝利: 580
引き分け: 0

=== 最終結果 ===
レバレッジETF勝率（実測）: 42.0%
通常ETF勝率（実測）: 58.0%

✓ 結果は理論値と整合している（期待: < 50%）
```

**使い方：**
1. ブラウザの開発者ツールを開く（F12）
2. Consoleタブを選択
3. シミュレーション実行ボタンをクリック
4. コンソールに詳細な検証結果が表示される

**新機能：**

1. **勝敗判定**
   - 各シミュレーション試行で、最終資産額を比較
   - レバレッジETF（L=設定値）> 通常ETF（L=1）→ レバレッジの勝利
   - 通常ETF（L=1）> レバレッジETF（L=設定値）→ 通常ETFの勝利

2. **円グラフ表示**
   - オレンジ: レバレッジETF勝利
   - 青: 通常ETF勝利
   - Chart.jsで美しい円グラフ

3. **統計情報**
   - 各勝利回数
   - 勝率（パーセンテージ）
   - シミュレーション試行回数

**実装コード：**
```javascript
// 勝敗を計算
let leverageWins = 0;
let normalWins = 0;

for (let i = 0; i < finalValues1.length; i++) {
    if (finalValuesL[i] > finalValues1[i]) {
        leverageWins++;
    } else {
        normalWins++;
    }
}

const leverageWinRate = (leverageWins / totalTrials * 100).toFixed(1);
```

**グラフ構成の更新：**
- グラフ1: 資産分布の比較（理論分布）
- グラフ2: モンテカルロシミュレーション時系列
- グラフ3: モンテカルロ最終資産分布
- グラフ4: **レバレッジETF vs 通常ETF 勝敗**（NEW!）

**活用シーン：**
- レバレッジETFが勝つ確率を視覚的に確認
- 投資期間・パラメータによる勝率の変化を分析
- 期待値は高いが勝率は低い、などの統計的な特性を理解

**重要な注意：**
勝率は中央値の比較と関連します：
- **理論中央値（L=3） > 理論中央値（L=1）** の場合 → レバレッジETFの勝率は50%以上
- **理論中央値（L=3） < 理論中央値（L=1）** の場合 → レバレッジETFの勝率は50%以下
- デフォルトパラメータ（μ=14%, σ=34%, b=3%, c=0.95%）では、短期ではレバレッジETFの中央値が高いため勝率も高くなります
- しかし、長期間やボラティリティが高い場合、コストの影響で通常ETFが有利になることがあります

### v1.5.0 - グラフ2（統計的優位ゾーン）を削除

**変更内容：**
グラフ2（統計的優位ゾーン）を削除し、シミュレーターをよりシンプルで分かりやすくしました。

**削除理由：**
- グラフ1で理論分布を確認できる
- サイドバーに中央値優位上限・最頻値優位上限が表示されている
- グラフを減らしてシンプルに

**変更後のグラフ構成：**
- **グラフ1**: 資産分布の比較（理論分布）
- **グラフ2**: モンテカルロシミュレーション時系列（旧グラフ3）
- **グラフ3**: モンテカルロ最終資産分布（旧グラフ4）

**統計情報の確認方法：**
- 中央値優位上限: サイドバーの「中央値優位上限」カード
- 最頻値優位上限: サイドバーの「最頻値優位上限」カード
- リスクプレミアム: サイドバーの「リスクプレミアム」カード

### v1.4.2 - グラフ4の線形X軸範囲をグラフ1と統一

**改良内容：**
グラフ4の線形X軸表示時の範囲をグラフ1と同じにして、比較しやすくしました。

**変更点：**

**グラフ1のX軸範囲（線形）:**
```javascript
const xMax = Math.min(Math.max(10, T * 2), 50);
// 範囲: 0 〜 xMax
```

**グラフ4のX軸範囲（修正後）:**
```javascript
// 線形スケール時
min: 0
max: Math.min(Math.max(10, T * 2), 50)  // グラフ1と同じ

// 対数スケール時
min: undefined  // 自動調整
max: undefined  // 自動調整
```

**X軸範囲の計算式：**
```
xMax = min(max(10, T × 2), 50)

例：
- T = 1年 → xMax = 10
- T = 5年 → xMax = 10
- T = 10年 → xMax = 20
- T = 15年 → xMax = 30
- T = 20年 → xMax = 40
- T = 30年 → xMax = 50（上限）
```

**メリット：**
- ✅ グラフ1とグラフ4を並べて比較しやすい
- ✅ 同じX軸範囲で理論分布とシミュレーション結果を確認
- ✅ 投資期間に応じて自動調整（10〜50倍の範囲）

**使い方：**
1. グラフ4のX軸を「線形に切替」
2. グラフ1とグラフ4のX軸範囲が一致
3. 理論分布（グラフ1）とシミュレーション結果（グラフ4）を比較

### v1.4.1 - グラフ4の確率密度正規化を修正（重要なバグ修正）

**修正内容：**
グラフ4のヒストグラム正規化方法に誤りがあり、理論分布曲線とのズレが発生していた問題を修正しました。

**問題点：**
- 対数空間でビンを作成しているのに、確率密度の計算方法が不適切
- 各ビンの幅が指数的に増加することを考慮していなかった
- 結果として、ヒストグラムと理論曲線の高さが一致しなかった

**解決策：**
```javascript
// 修正前（誤り）：面積ベースの正規化
const totalArea1 = histogram1.reduce((sum, count, i) => {
    const binWidth = binCenters[i + 1] - binCenters[i];
    return sum + count * binWidth;
}, 0);
const densities1 = histogram1.map((count, i) => count / totalArea1);

// 修正後（正しい）：確率密度の定義に基づく正規化
const total1 = finalRatios1.length;
const densities1 = histogram1.map((count, i) => {
    return count / (total1 * binWidths[i]);
});
```

**確率密度の正しい定義：**
```
確率密度 = (ビン内のカウント数) / (全サンプル数 × ビンの幅)
```

**効果：**
- ✅ ヒストグラムと理論曲線の高さが正確に一致
- ✅ 対数軸でも線形軸でも正しく表示
- ✅ シミュレーション回数を増やすほど理論曲線に収束
- ✅ 統計的に正確な確率密度表示

### v1.4.0 - グラフ4のスケール切り替え＆シミュレーション回数拡大

**改良内容：**
グラフ4に対数/線形スケール切り替え機能を追加し、シミュレーション回数の上限を大幅に拡大しました。

**主な変更点：**

1. **グラフ4のスケール切り替え機能**
   - **X軸切り替えボタン**: 対数軸 ⇔ 線形軸
   - **Y軸切り替えボタン**: 線形軸 ⇔ 対数軸
   - ボタンクリックで即座に切り替え（再計算不要）
   - スケール状態をメモリに保持

2. **シミュレーション回数の拡大**
   - **従来**: 1〜500回
   - **改良後**: 1〜5,000回
   - 高精度な統計分析が可能に
   - 理論値との一致度を詳細に確認可能

3. **スケール切り替えの利点**
   
   **X軸（対数 vs 線形）:**
   - **対数軸**（デフォルト）: 広範囲の倍率を一目で把握
   - **線形軸**: 低倍率領域の詳細な分布を確認
   
   **Y軸（線形 vs 対数）:**
   - **線形軸**（デフォルト）: 確率密度の直感的な理解
   - **対数軸**: 低頻度の外れ値（テール）を詳細に確認

4. **実装の工夫**
   ```javascript
   // スケール状態を保持
   let distScaleState = {
       xScale: 'logarithmic', // デフォルトは対数
       yScale: 'linear' // デフォルトは線形
   };
   
   // 最後のシミュレーション結果を保存
   window.lastDistributionData = { ... };
   
   // ボタンクリックで再描画（再計算不要）
   ```

**使用シーン：**

| シミュレーション回数 | 用途 |
|---------------------|------|
| **1〜100回** | 分散の大きさを体感 |
| **100〜1,000回** | 標準的な確率分布の確認 |
| **1,000〜10,000回** | 高精度な統計分析 |
| **3,000〜5,000回** | 理論値との詳細な一致確認、高精度分析 |

**スケール組み合わせ：**

| X軸 | Y軸 | 用途 |
|-----|-----|------|
| **対数** | **線形** | 標準（広範囲を見やすく） |
| **線形** | **線形** | 低倍率領域の詳細分析 |
| **対数** | **対数** | テール（外れ値）の詳細確認 |
| **線形** | **対数** | 特殊な分析 |

### v1.3.1 - シミュレーション実行ボタンの追加

**改良内容：**
リアルタイム更新による遅延を解消し、ユーザーが任意のタイミングでシミュレーションを実行できるようにしました。

**主な変更点：**

1. **実行ボタンの追加**
   - 🚀 シミュレーション実行ボタンを追加
   - パラメータ変更時は値の表示のみ更新（軽量）
   - ボタンクリック時のみグラフを再計算・更新

2. **UI/UX改善**
   - **実行中の視覚的フィードバック**：ボタンが「⏳ 実行中...」に変化
   - **ローディング表示**：計算中であることを明確に表示
   - **ボタンの無効化**：実行中は連続クリックを防止
   - **ホバーエフェクト**：美しいボタンアニメーション

3. **パフォーマンス向上**
   - パラメータ調整時の遅延がゼロに
   - シミュレーション回数500回でも快適
   - ユーザーが最適なパラメータを設定してから実行可能

**ボタンスタイル：**
```css
#run-simulation {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
}

#run-simulation:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
}
```

**使い方：**
1. スライダーでパラメータを調整（即座に値が表示される）
2. 最適なパラメータが決まったら「🚀 シミュレーション実行」をクリック
3. グラフが更新される（計算中はボタンが無効化）

### v1.3.0 - グラフ4をChart.jsベースに刷新

**改良内容：**
グラフ4（モンテカルロ最終資産分布）をPlotly.jsからChart.jsベースに変更し、表示品質と パフォーマンスを大幅に向上させました。

**主な変更点：**

1. **ライブラリの追加**
   - Chart.jsをCDN経由で導入
   - より軽量で高速なレンダリング

2. **ヒストグラムの改良**
   - **対数スケールでビンを作成**：対数正規分布に最適化
   - **確率密度に正規化**：面積=1になるよう調整
   - **100ビン**：より滑らかな分布表示
   - **X軸が対数軸**：広範囲のデータを見やすく表示

3. **視覚的改善**
   - L=1とL=3のヒストグラムを半透明で重ね合わせ表示
   - 理論分布曲線を滑らかな線で描画（500点）
   - より直感的な色分け（L=1: 青、L=3: オレンジ）
   - インタラクティブなツールチップ

4. **パフォーマンス向上**
   - Chart.jsの軽量性により描画速度が向上
   - 500回シミュレーションでもスムーズに動作

**技術的詳細：**
```javascript
// 対数空間でビンを作成
const logMin = Math.log(Math.max(0.01, minRatio));
const logMax = Math.log(maxRatio * 1.1);
const logBinWidth = (logMax - logMin) / numBins;

// ビンの中心値（対数空間で等間隔）
const binCenters = [];
for (let i = 0; i < numBins; i++) {
    const logCenter = logMin + (i + 0.5) * logBinWidth;
    binCenters.push(Math.exp(logCenter));
}
```

**ユーザーメリット：**
- ✅ より見やすく美しいヒストグラム表示
- ✅ 対数軸により広範囲の倍率を一目で把握
- ✅ 理論分布との一致度が視覚的に確認しやすい
- ✅ 軽快な動作でストレスフリー

### v1.2.2 - 原指数共有による連動性の修正（重要なバグ修正）

**修正内容：**
シミュレーション回数を1回にしたときに、元のETF（L=1）とレバレッジETF（L=3など）が連動していなかった問題を修正しました。

**問題点：**
- 従来：L=1とL=3のシミュレーションで**別々の原指数**を生成していた
- 結果：同じ市場を想定しているのに、まったく異なる動きをしていた

**解決策：**
シミュレーション構造を2関数に分離：

1. **`generateIndexSimulations()`**: 原指数（SOX）のシミュレーションを生成
2. **`trackIndexWithLeverage()`**: 同じ原指数から異なるレバレッジ倍率のETFを追跡

```javascript
// ステップ1: 原指数を生成（全シミュレーションで共有）
const indexSimulations = generateIndexSimulations(mu, sigma, T, numSimulations);

// ステップ2: 同じ原指数から L=1 と L=設定値 の両方のETFを追跡
const trajectories1 = trackIndexWithLeverage(indexSimulations, 1, b, c, initialValue);
const trajectoriesL = trackIndexWithLeverage(indexSimulations, L, b, c, initialValue);
```

**効果：**
- ✅ シミュレーション回数1回でも、L=1とL=3が同じ原指数の動きに連動
- ✅ L=1の動きはほぼ原指数と同じ（コストc分だけ下がる）
- ✅ L=3はL=1の日次変動を3倍に増幅した動き
- ✅ より現実的で直感的なシミュレーション結果

### v1.2.1 - シミュレーション回数の最小値調整

**改良内容：**
モンテカルロシミュレーションの試行回数をより柔軟に設定可能にしました：

- **最小値を10回から1回に変更**：少ない試行回数での統計的挙動を観察可能
- **ステップを10刻みから1刻みに変更**：より細かい調整が可能
- **用途**：
  - 少数サンプルでのバラツキを体感的に理解
  - 教育目的での分散の大きさの可視化
  - 軽量な動作確認や検証作業

**変更点：**
```html
<!-- 変更前 -->
<input type="range" id="simulations" min="10" max="500" step="10" value="100">
モンテカルロの試行回数（10〜500回、多いほど精度向上）

<!-- 変更後 -->
<input type="range" id="simulations" min="1" max="500" step="1" value="100">
モンテカルロの試行回数（1〜500回、多いほど精度向上）
```

### v1.2.0 - 2段階シミュレーションモデルへの改良

**改良内容：**
モンテカルロシミュレーションを**2段階プロセス**に変更し、より現実的なレバレッジETFの動作を再現：

```javascript
// ステップ1: 原指数（SOX）をシミュレーション
for (day = 1 to totalDays) {
    indexReturn = (μ - 0.5σ²)dt + σ√dt * Z
    indexPrice[day] = indexPrice[day-1] * exp(indexReturn)
}

// ステップ2: レバレッジETFが原指数に連動
for (day = 1 to totalDays) {
    dailyIndexReturn = log(indexPrice[day] / indexPrice[day-1])
    leveragedReturn = L * dailyIndexReturn
    ETFprice[day] = ETFprice[day-1] * exp(leveragedReturn) * costFactor
}
```

**利点：**
- 原指数とレバレッジETFの因果関係を明確に表現
- 同じ原指数の動きに対して、複数のレバレッジETF（2倍、3倍など）を比較可能
- より直感的で理解しやすいモデル
- 実際のレバレッジETFの仕組み（原指数の日次リターンを増幅）を正確に再現

### v1.1.0 - 日次リバランスモデルへの修正

**問題点：**
以前のバージョンでは、レバレッジETFを独立したGBM（幾何ブラウン運動）としてモデル化していました。これは理論的には正しい最終分布を与えますが、日々の価格変動（パス）が実際のレバレッジETFとは異なっていました。

**修正内容：**
モンテカルロシミュレーション（グラフ3、4）を**日次リバランスモデル**に変更し、パス依存性（経路依存性）を正しく反映しました。

---

## ⚠️ 注意事項

### 📊 実際の株価との乖離について

**重要：このシミュレーターが示すものと実際の株価の違い**

#### 1. **根本的な違い：「実現値」vs「確率分布」**

| 実際の株価 | このシミュレーション |
|-----------|---------------------|
| **1つの実現したパス** | **起こりうる無数の可能性** |
| 過去の「結果」 | 未来の「不確実性」 |
| 確定した事実 | 確率的な予測 |

**例え話：**
- **実際の株価** = サイコロを振って出た「6」という結果
- **このシミュレーション** = サイコロを振る前の「1〜6が出る可能性」の分布

#### 2. **なぜ乖離するのか（5つの主要因）**

##### ① **ドリフト(μ)は推定値に過ぎない**
- シミュレーションでは過去データから推定した「14%」を使用
- しかし、実際の将来リターンは：
  - 経済状況の変化
  - 市場センチメント
  - 規制・政策変更
  - 技術革新のペース
  - などにより大きく変動

**実際のSOXLの年次リターン例：**
- 2023年: +180%（大幅上昇）
- 2022年: -80%（大幅下落）
- 平均14%とは大きく異なる実現値

##### ② **ボラティリティも固定ではない**
- シミュレーション：σ = 34%（固定）
- 実際の市場：
  - 平穏期：σ ≈ 20%
  - 危機時：σ ≈ 60%以上
  - ボラティリティ自体が変動（ボラティリティ・クラスタリング）

##### ③ **対数正規分布は完全なモデルではない**
実際の株価の特徴（モデル化されていない）：
- **ファット・テール**：極端な値が理論より多い
- **非対称性**：下落時と上昇時で異なる動き
- **ジャンプ**：連続的でない急激な変動
- **マクロショック**：パンデミック、戦争、金融危機など

##### ④ **市場の構造変化**
- セクターローテーション
- AI/半導体需要の急変
- 競合関係の変化
- サプライチェーンの混乱
- これらは過去データに含まれない新しい要因

##### ⑤ **ブラックスワン・イベント**
- 過去のデータでは予測不可能な事象
- COVID-19、リーマンショック、ドットコムバブル崩壊など
- これらは「確率分布の外側」の事象

#### 3. **シミュレーションの正しい解釈**

❌ **誤った解釈：**
- 「SOXLは1年後に150万円になる」
- 「このグラフ通りに動く」
- 「過去のデータで未来が予測できる」

✅ **正しい解釈：**
- 「現在の前提条件が続くなら、このような確率分布になる**可能性がある**」
- 「不確実性の範囲を理解するためのツール」
- 「リスクとリターンのトレードオフを視覚化」
- 「最悪シナリオ・最良シナリオの幅を把握」

#### 4. **シミュレーションの価値**

実際の株価と異なっても、このツールは有用です：

✅ **リスクの定量化**
- 元本割れの確率
- 期待値と中央値の乖離
- ボラティリティの影響

✅ **感度分析**
- パラメータ変更による影響確認
- レバレッジ倍率の比較
- 投資期間の影響評価

✅ **教育的価値**
- レバレッジETFの仕組み理解
- ボラティリティ減価の可視化
- 確率的思考の訓練

✅ **リスク管理**
- 最悪シナリオの準備
- ポジションサイズの決定
- 心理的な準備

#### 5. **推奨される使い方**

1. **複数のシナリオを試す**
   - ドリフト：10%、14%、20%
   - ボラティリティ：25%、34%、45%
   - 様々な前提での結果を確認

2. **最悪ケースに備える**
   - 線形スケールで下振れリスクを確認
   - 最小値が許容範囲内か検証

3. **実際のデータと組み合わせる**
   - 過去の実績チャートも参照
   - 複数の情報源を活用

4. **定期的に見直す**
   - 市場環境の変化に応じてパラメータ更新
   - 実績との乖離を分析して学習

---

### 免責事項

このシミュレーターは教育・情報提供を目的としており、投資助言ではありません：

- **モデルの限界**: 実際の市場は対数正規分布に完全には従いません
- **パラメータの不確実性**: ドリフトやボラティリティは過去データからの推定値
- **予測ではない**: 将来の株価を予測するものではありません
- **コストの簡略化**: リバランスコストや税金は考慮されていません
- **過去の実績**: 過去のパラメータが将来も継続する保証はありません
- **投資判断**: 必ずご自身で調査・判断の上、投資を行ってください

### 技術的制約

- **静的サイト**: サーバーサイド処理は行いません
- **クライアント計算**: すべての計算はブラウザ上で実行されます
- **データ永続化**: 現在、設定の自動保存機能はありません（今後実装予定）

## 📄 ライセンス

このプロジェクトは教育目的で作成されています。

## 🤝 貢献

改善提案やバグ報告を歓迎します！

---

**最終更新**: 2025年10月  
**バージョン**: 1.0.0  
**作成者**: レバレッジETFシミュレータープロジェクトチーム
